
# 🎯 "배열을 해시맵처럼 사용" 패턴

배열 자체를 **인덱스-값 매핑** 도구로 사용하여 추가 메모리(해시맵, Set)를 절약하는 기법입니다.

## 🔴 심화: 창의적인 배열 활용

### 1. First Missing Positive (LeetCode 41) [hard]
- [ ] [41. First Missing Positive](https://leetcode.com/problems/first-missing-positive/)

**문제:** 정렬되지 않은 정수 배열에서 **가장 작은 양의 정수(1 이상)가 빠져있는 수**를 찾아라. $O(n)$ 시간, $O(1)$ 공간.

**핵심:** **배열 자체를 "방문 기록" 해시맵으로 활용**

**논리:**
1. 1부터 n까지의 수만 의미 있음 (n+1은 답이 될 수 있음).
2. 각 숫자를 "올바른 위치"로 배치: 숫자 `k`는 `nums[k-1]` 위치에 배치.
3. 첫 번째 순회에서 배치 완료.
4. 두 번째 순회에서 `i` 위치에 `i+1`이 없으면, `i+1`이 답.


**추천 이유:** 
- **배열을 해시맵처럼 사용**하는 창의적인 접근법.
- $O(1)$ 추가 공간 제약 조건을 만족하면서 $O(n)$ 해결.
- 인터뷰에서 자주 나오는 **문제 해결 능력 테스트** 문제입니다.

**난이도:** Hard (개념이 어려움)

### 2. Find the Duplicate Number (LeetCode 287) [medium]
- [ ] [287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/)

**문제:** 1부터 n까지의 숫자가 n+1개 있을 때, **중복된 숫자 하나**를 찾아라. $O(n)$ 시간, $O(1)$ 공간. (배열 수정 금지)

**핵심:** **Floyd의 Cycle Detection (거북이와 토끼)** 또는 **배열 인덱스를 링크드 리스트처럼 해석**

**논리:**
- 배열을 **연결 리스트**로 해석: `nums[i]` = 다음 노드의 인덱스.
- 중복된 숫자 = 여러 노드에서 가리키는 값 = 사이클의 시작점.
- Floyd 알고리즘으로 사이클 찾기.

**추천 이유:** 
- 배열을 **그래프 구조**로 재해석하는 창의적 사고.
- $O(1)$ 공간 제약에서 사이클 탐지 알고리즘 학습.
- 인터뷰에서 **상위 1% 문제** 중 하나.

**난이도:** Medium (개념이 어려움)

### 3. Majority Element (LeetCode 169) [easy]
- [ ] [169. Majority Element](https://leetcode.com/problems/majority-element/)

**문제:** 배열에서 **절반 이상 차지하는 원소**를 찾아라. $O(n)$ 시간, $O(1)$ 공간.

**핵심:** **Boyer-Moore Voting Algorithm** - 투표 기반 알고리즘

**논리:**
- `candidate` = 현재 후보, `count` = 투표 수.
- 현재 원소가 `candidate`와 같으면 `count++`, 다르면 `count--`.
- `count == 0`이면 `candidate` 변경.
- 절반 이상이므로 마지막 `candidate`가 답.

**추천 이유:**
- **상수 공간**에서 다수 원소 찾기.
- 대규모 데이터 스트리밍 문제에서 실무 응용.
- 직관적이면서도 우아한 알고리즘.

**난이도:** Easy (알고리즘 이해 필요)

### 4. Single Number (LeetCode 136) [easy]
- [ ] [136. Single Number](https://leetcode.com/problems/single-number/)

**문제:** 배열의 모든 원소가 2번씩 나타나고, **하나만 1번** 나타난다. 그 숫자를 찾아라. $O(n)$ 시간, $O(1)$ 공간.

**핵심:** **XOR(배타적 논리합) 성질 활용**

**논리:**
- XOR의 성질: `a ^ a = 0`, `a ^ 0 = a`, XOR은 교환/결합 법칙 성립.
- 모든 원소를 XOR로 연결: 2번 나타나는 것들끼리 소거되고, 1번 나타나는 것만 남음.

**추천 이유:**
- **비트 연산**의 우아한 활용.
- 추가 메모리 없이 수학적 성질로 문제 해결.
- 코딩 인터뷰에서 자주 나오는 **클래식 문제**.

**난이도:** Easy (개념 간단, 성능 최적)

---

## 💡 학습 포인트

이 패턴들을 통해 배웠던 것:
- **누적 합(Prefix Sum):** 정보 재활용으로 $O(n^2) \to O(n)$ 최적화.
- **양방향 순회:** 복잡한 조건도 단순한 선형 탐색으로 해결.
- **상태 기계:** 단순 "누적"이 아닌 "상태 관리"의 중요성.
- **배열 재활용:** 추가 메모리 없이 배열 자체를 도구로 활용.
- **사이클 탐지:** Floyd 알고리즘으로 그래프 구조 문제 해결.
- **투표 알고리즘:** 다수 원소 찾기의 최적 방법.
- **비트 연산:** XOR로 메모리 절약한 수학적 풀이.

---
